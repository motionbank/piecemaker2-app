.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH X509_STORE_CTX_set_verify_cb 3 "1.0.1e" "11/Feb/2013" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
X509_STORE_CTX_set_verify_cb \- set verification callback
.SH "SYNOPSIS"
.PP
.Vb 1
\& #include <openssl/x509_vfy.h>
.Ve
.Vb 2
\& void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
\&                                int (*verify_cb)(int ok, X509_STORE_CTX *ctx));
.Ve
.SH "DESCRIPTION"
\fIX509_STORE_CTX_set_verify_cb()\fR sets the verification callback of \fBctx\fR to
\fBverify_cb\fR overwriting any existing callback.
.PP
The verification callback can be used to customise the operation of certificate
verification, either by overriding error conditions or logging errors for
debugging purposes.
.PP
However a verification callback is \fBnot\fR essential and the default operation
is often sufficient.
.PP
The \fBok\fR parameter to the callback indicates the value the callback should
return to retain the default behaviour. If it is zero then and error condition
is indicated. If it is 1 then no error occurred. If the flag
\fBX509_V_FLAG_NOTIFY_POLICY\fR is set then \fBok\fR is set to 2 to indicate the
policy checking is complete.
.PP
The \fBctx\fR parameter to the callback is the \fBX509_STORE_CTX\fR structure that
is performing the verification operation. A callback can examine this
structure and receive additional information about the error, for example
by calling \fIX509_STORE_CTX_get_current_cert()\fR. Additional application data can
be passed to the callback via the \fBex_data\fR mechanism.
.SH "WARNING"
In general a verification callback should \fBNOT\fR unconditionally return 1 in
all circumstances because this will allow verification to succeed no matter
what the error. This effectively removes all security from the application
because \fBany\fR certificate (including untrusted generated ones) will be
accepted.
.SH "NOTES"
The verification callback can be set and inherited from the parent structure
performing the operation. In some cases (such as S/MIME verification) the
\fBX509_STORE_CTX\fR structure is created and destroyed internally and the
only way to set a custom verification callback is by inheriting it from the
associated \fBX509_STORE\fR.
.SH "RETURN VALUES"
\fIX509_STORE_CTX_set_verify_cb()\fR does not return a value.
.SH "EXAMPLES"
Default callback operation:
.PP
.Vb 4
\& int verify_callback(int ok, X509_STORE_CTX *ctx)
\&        {
\&        return ok;
\&        }
.Ve
Simple example, suppose a certificate in the chain is expired and we wish
to continue after this error:
.PP
.Vb 8
\& int verify_callback(int ok, X509_STORE_CTX *ctx)
\&        {
\&        /* Tolerate certificate expiration */
\&        if (X509_STORE_CTX_get_error(ctx) == X509_V_ERR_CERT_HAS_EXPIRED)
\&                        return 1;
\&        /* Otherwise don't override */
\&        return ok;
\&        }
.Ve
More complex example, we don't wish to continue after \fBany\fR certificate has
expired just one specific case:
.PP
.Vb 11
\& int verify_callback(int ok, X509_STORE_CTX *ctx)
\&        {
\&        int err = X509_STORE_CTX_get_error(ctx);
\&        X509 *err_cert = X509_STORE_CTX_get_current_cert(ctx);
\&        if (err == X509_V_ERR_CERT_HAS_EXPIRED)
\&                {
\&                if (check_is_acceptable_expired_cert(err_cert)
\&                        return 1;
\&                }
\&        return ok;
\&        }
.Ve
Full featured logging callback. In this case the \fBbio_err\fR is assumed to be
a global logging \fBBIO\fR, an alternative would to store a BIO in \fBctx\fR using
\fBex_data\fR.
	
 int \fIverify_callback\fR\|(int ok, X509_STORE_CTX *ctx)
	{
	X509 *err_cert;
	int err,depth;
.PP
.Vb 3
\&        err_cert = X509_STORE_CTX_get_current_cert(ctx);
\&        err =   X509_STORE_CTX_get_error(ctx);
\&        depth = X509_STORE_CTX_get_error_depth(ctx);
.Ve
.Vb 38
\&        BIO_printf(bio_err,"depth=%d ",depth);
\&        if (err_cert)
\&                {
\&                X509_NAME_print_ex(bio_err, X509_get_subject_name(err_cert),
\&                                        0, XN_FLAG_ONELINE);
\&                BIO_puts(bio_err, "\en");
\&                }
\&        else
\&                BIO_puts(bio_err, "<no cert>\en");
\&        if (!ok)
\&                BIO_printf(bio_err,"verify error:num=%d:%s\en",err,
\&                        X509_verify_cert_error_string(err));
\&        switch (err)
\&                {
\&        case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
\&                BIO_puts(bio_err,"issuer= ");
\&                X509_NAME_print_ex(bio_err, X509_get_issuer_name(err_cert),
\&                                        0, XN_FLAG_ONELINE);
\&                BIO_puts(bio_err, "\en");
\&                break;
\&        case X509_V_ERR_CERT_NOT_YET_VALID:
\&        case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
\&                BIO_printf(bio_err,"notBefore=");
\&                ASN1_TIME_print(bio_err,X509_get_notBefore(err_cert));
\&                BIO_printf(bio_err,"\en");
\&                break;
\&        case X509_V_ERR_CERT_HAS_EXPIRED:
\&        case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
\&                BIO_printf(bio_err,"notAfter=");
\&                ASN1_TIME_print(bio_err,X509_get_notAfter(err_cert));
\&                BIO_printf(bio_err,"\en");
\&                break;
\&        case X509_V_ERR_NO_EXPLICIT_POLICY:
\&                policies_print(bio_err, ctx);
\&                break;
\&                }
\&        if (err == X509_V_OK && ok == 2)
\&                /* print out policies */
.Ve
.Vb 3
\&        BIO_printf(bio_err,"verify return:%d\en",ok);
\&        return(ok);
\&        }
.Ve
.SH "SEE ALSO"
X509_STORE_CTX_get_error(3)
X509_STORE_set_verify_cb_func(3)
X509_STORE_CTX_get_ex_new_index(3)
.SH "HISTORY"
\fIX509_STORE_CTX_set_verify_cb()\fR is available in all versions of SSLeay and
OpenSSL.

.rn }` ''
.IX Title "X509_STORE_CTX_set_verify_cb 3"
.IX Name "X509_STORE_CTX_set_verify_cb - set verification callback"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "WARNING"

.IX Header "NOTES"

.IX Header "RETURN VALUES"

.IX Header "EXAMPLES"

.IX Header "SEE ALSO"

.IX Header "HISTORY"

