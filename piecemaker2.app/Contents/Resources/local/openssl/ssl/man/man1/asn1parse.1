.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH ASN1PARSE 1 "1.0.1e" "11/Feb/2013" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
asn1parse \- ASN.1 parsing tool
.SH "SYNOPSIS"
\fBopenssl\fR \fBasn1parse\fR
[\fB\-inform PEM|DER\fR]
[\fB\-in filename\fR]
[\fB\-out filename\fR]
[\fB\-noout\fR]
[\fB\-offset number\fR]
[\fB\-length number\fR]
[\fB\-i\fR]
[\fB\-oid filename\fR]
[\fB\-strparse offset\fR]
[\fB\-genstr string\fR]
[\fB\-genconf file\fR]
.SH "DESCRIPTION"
The \fBasn1parse\fR command is a diagnostic utility that can parse ASN.1
structures. It can also be used to extract data from ASN.1 formatted data.
.SH "OPTIONS"
.Ip "\fB\-inform\fR \fB\s-1DER\s0|\s-1PEM\s0\fR" 4
the input format. \fB\s-1DER\s0\fR is binary format and \fB\s-1PEM\s0\fR (the default) is base64
encoded.
.Ip "\fB\-in filename\fR" 4
the input file, default is standard input
.Ip "\fB\-out filename\fR" 4
output file to place the \s-1DER\s0 encoded data into. If this
option is not present then no data will be output. This is most useful when
combined with the \fB\-strparse\fR option.
.Ip "\fB\-noout\fR" 4
don't output the parsed version of the input file.
.Ip "\fB\-offset number\fR" 4
starting offset to begin parsing, default is start of file.
.Ip "\fB\-length number\fR" 4
number of bytes to parse, default is until end of file.
.Ip "\fB\-i\fR" 4
indents the output according to the \*(L"depth\*(R" of the structures.
.Ip "\fB\-oid filename\fR" 4
a file containing additional \s-1OBJECT\s0 IDENTIFIERs (OIDs). The format of this
file is described in the \s-1NOTES\s0 section below.
.Ip "\fB\-strparse offset\fR" 4
parse the contents octets of the \s-1ASN\s0.1 object starting at \fBoffset\fR. This
option can be used multiple times to \*(L"drill down\*(R" into a nested structure.
.Ip "\fB\-genstr string\fR, \fB\-genconf file\fR" 4
generate encoded data based on \fBstring\fR, \fBfile\fR or both using
ASN1_generate_nconf(3) format. If \fBfile\fR only is
present then the string is obtained from the default section using the name
\fBasn1\fR. The encoded data is passed through the \s-1ASN1\s0 parser and printed out as
though it came from a file, the contents can thus be examined and written to a
file using the \fBout\fR option. 
.Sh "\s-1OUTPUT\s0"
The output will typically contain lines like this:
.PP
.Vb 1
\&  0:d=0  hl=4 l= 681 cons: SEQUENCE          
.Ve
\&.....
.PP
.Vb 10
\&  229:d=3  hl=3 l= 141 prim: BIT STRING        
\&  373:d=2  hl=3 l= 162 cons: cont [ 3 ]        
\&  376:d=3  hl=3 l= 159 cons: SEQUENCE          
\&  379:d=4  hl=2 l=  29 cons: SEQUENCE          
\&  381:d=5  hl=2 l=   3 prim: OBJECT            :X509v3 Subject Key Identifier
\&  386:d=5  hl=2 l=  22 prim: OCTET STRING      
\&  410:d=4  hl=2 l= 112 cons: SEQUENCE          
\&  412:d=5  hl=2 l=   3 prim: OBJECT            :X509v3 Authority Key Identifier
\&  417:d=5  hl=2 l= 105 prim: OCTET STRING      
\&  524:d=4  hl=2 l=  12 cons: SEQUENCE          
.Ve
\&.....
.PP
This example is part of a self signed certificate. Each line starts with the
offset in decimal. \fBd=\s-1XX\s0\fR specifies the current depth. The depth is increased
within the scope of any \s-1SET\s0 or \s-1SEQUENCE\s0. \fBhl=\s-1XX\s0\fR gives the header length
(tag and length octets) of the current type. \fBl=\s-1XX\s0\fR gives the length of
the contents octets.
.PP
The \fB\-i\fR option can be used to make the output more readable.
.PP
Some knowledge of the \s-1ASN\s0.1 structure is needed to interpret the output. 
.PP
In this example the \s-1BIT\s0 \s-1STRING\s0 at offset 229 is the certificate public key.
The contents octets of this will contain the public key information. This can
be examined using the option \fB\-strparse 229\fR to yield:
.PP
.Vb 3
\&    0:d=0  hl=3 l= 137 cons: SEQUENCE          
\&    3:d=1  hl=3 l= 129 prim: INTEGER           :E5D21E1F5C8D208EA7A2166C7FAF9F6BDF2059669C60876DDB70840F1A5AAFA59699FE471F379F1DD6A487E7D5409AB6A88D4A9746E24B91D8CF55DB3521015460C8EDE44EE8A4189F7A7BE77D6CD3A9AF2696F486855CF58BF0EDF2B4068058C7A947F52548DDF7E15E96B385F86422BEA9064A3EE9E1158A56E4A6F47E5897
\&  135:d=1  hl=2 l=   3 prim: INTEGER           :010001
.Ve
.SH "NOTES"
If an OID is not part of OpenSSL's internal table it will be represented in
numerical form (for example 1.2.3.4). The file passed to the \fB\-oid\fR option 
allows additional OIDs to be included. Each line consists of three columns,
the first column is the OID in numerical format and should be followed by white
space. The second column is the \*(L"short name\*(R" which is a single word followed
by white space. The final column is the rest of the line and is the
\*(L"long name\*(R". \fBasn1parse\fR displays the long name. Example:
.PP
\f(CW1.2.3.4	shortName	A long name\fR
.SH "EXAMPLES"
Parse a file:
.PP
.Vb 1
\& openssl asn1parse -in file.pem
.Ve
Parse a DER file:
.PP
.Vb 1
\& openssl asn1parse -inform DER -in file.der
.Ve
Generate a simple UTF8String:
.PP
.Vb 1
\& openssl asn1parse -genstr 'UTF8:Hello World'
.Ve
Generate and write out a UTF8String, don't print parsed output:
.PP
.Vb 1
\& openssl asn1parse -genstr 'UTF8:Hello World' -noout -out utf8.der
.Ve
Generate using a config file:
.PP
.Vb 1
\& openssl asn1parse -genconf asn1.cnf -noout -out asn1.der
.Ve
Example config file:
.PP
.Vb 1
\& asn1=SEQUENCE:seq_sect
.Ve
.Vb 1
\& [seq_sect]
.Ve
.Vb 2
\& field1=BOOL:TRUE
\& field2=EXP:0, UTF8:some random string
.Ve
.SH "BUGS"
There should be options to change the format of output lines. The output of some
ASN.1 types is not well handled (if at all).
.SH "SEE ALSO"
ASN1_generate_nconf(3)

.rn }` ''
.IX Title "ASN1PARSE 1"
.IX Name "asn1parse - ASN.1 parsing tool"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "OPTIONS"

.IX Item "\fB\-inform\fR \fB\s-1DER\s0|\s-1PEM\s0\fR"

.IX Item "\fB\-in filename\fR"

.IX Item "\fB\-out filename\fR"

.IX Item "\fB\-noout\fR"

.IX Item "\fB\-offset number\fR"

.IX Item "\fB\-length number\fR"

.IX Item "\fB\-i\fR"

.IX Item "\fB\-oid filename\fR"

.IX Item "\fB\-strparse offset\fR"

.IX Item "\fB\-genstr string\fR, \fB\-genconf file\fR"

.IX Subsection "\s-1OUTPUT\s0"

.IX Header "NOTES"

.IX Header "EXAMPLES"

.IX Header "BUGS"

.IX Header "SEE ALSO"

