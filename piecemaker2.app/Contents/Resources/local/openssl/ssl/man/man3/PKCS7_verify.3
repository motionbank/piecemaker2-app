.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PKCS7_verify 3 "1.0.1e" "11/Feb/2013" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
PKCS7_verify \- verify a PKCS#7 signedData structure
.SH "SYNOPSIS"
.PP
.Vb 1
\& #include <openssl/pkcs7.h>
.Ve
.Vb 1
\& int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store, BIO *indata, BIO *out, int flags);
.Ve
.Vb 1
\& STACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs, int flags);
.Ve
.SH "DESCRIPTION"
\fIPKCS7_verify()\fR verifies a PKCS#7 signedData structure. \fBp7\fR is the PKCS7
structure to verify. \fBcerts\fR is a set of certificates in which to search for
the signer's certificate. \fBstore\fR is a trusted certficate store (used for
chain verification). \fBindata\fR is the signed data if the content is not
present in \fBp7\fR (that is it is detached). The content is written to \fBout\fR
if it is not NULL.
.PP
\fBflags\fR is an optional set of flags, which can be used to modify the verify
operation.
.PP
\fIPKCS7_get0_signers()\fR retrieves the signer's certificates from \fBp7\fR, it does
\fBnot\fR check their validity or whether any signatures are valid. The \fBcerts\fR
and \fBflags\fR parameters have the same meanings as in \fIPKCS7_verify()\fR.
.SH "VERIFY PROCESS"
Normally the verify process proceeds as follows.
.PP
Initially some sanity checks are performed on \fBp7\fR. The type of \fBp7\fR must
be signedData. There must be at least one signature on the data and if
the content is detached \fBindata\fR cannot be \fBNULL\fR.
.PP
An attempt is made to locate all the signer's certificates, first looking in
the \fBcerts\fR parameter (if it is not \fBNULL\fR) and then looking in any certificates
contained in the \fBp7\fR structure itself. If any signer's certificates cannot be
located the operation fails.
.PP
Each signer's certificate is chain verified using the \fBsmimesign\fR purpose and
the supplied trusted certificate store. Any internal certificates in the message
are used as untrusted CAs. If any chain verify fails an error code is returned.
.PP
Finally the signed content is read (and written to \fBout\fR is it is not NULL) and
the signature's checked.
.PP
If all signature's verify correctly then the function is successful.
.PP
Any of the following flags (ored together) can be passed in the \fBflags\fR parameter
to change the default verify behaviour. Only the flag \fBPKCS7_NOINTERN\fR is
meaningful to \fIPKCS7_get0_signers()\fR.
.PP
If \fBPKCS7_NOINTERN\fR is set the certificates in the message itself are not 
searched when locating the signer's certificate. This means that all the signers
certificates must be in the \fBcerts\fR parameter.
.PP
If the \fBPKCS7_TEXT\fR flag is set MIME headers for type \fBtext/plain\fR are deleted
from the content. If the content is not of type \fBtext/plain\fR then an error is
returned.
.PP
If \fBPKCS7_NOVERIFY\fR is set the signer's certificates are not chain verified.
.PP
If \fBPKCS7_NOCHAIN\fR is set then the certificates contained in the message are
not used as untrusted CAs. This means that the whole verify chain (apart from
the signer's certificate) must be contained in the trusted store.
.PP
If \fBPKCS7_NOSIGS\fR is set then the signatures on the data are not checked.
.SH "NOTES"
One application of \fBPKCS7_NOINTERN\fR is to only accept messages signed by
a small number of certificates. The acceptable certificates would be passed
in the \fBcerts\fR parameter. In this case if the signer is not one of the
certificates supplied in \fBcerts\fR then the verify will fail because the
signer cannot be found.
.PP
Care should be taken when modifying the default verify behaviour, for example
setting \fBPKCS7_NOVERIFY|PKCS7_NOSIGS\fR will totally disable all verification 
and any signed message will be considered valid. This combination is however
useful if one merely wishes to write the content to \fBout\fR and its validity
is not considered important.
.PP
Chain verification should arguably be performed  using the signing time rather
than the current time. However since the signing time is supplied by the
signer it cannot be trusted without additional evidence (such as a trusted
timestamp).
.SH "RETURN VALUES"
\fIPKCS7_verify()\fR returns 1 for a successful verification and zero or a negative
value if an error occurs.
.PP
\fIPKCS7_get0_signers()\fR returns all signers or \fBNULL\fR if an error occurred.
.PP
The error can be obtained from ERR_get_error(3)
.SH "BUGS"
The trusted certificate store is not searched for the signers certificate,
this is primarily due to the inadequacies of the current \fBX509_STORE\fR
functionality.
.PP
The lack of single pass processing and need to hold all data in memory as
mentioned in \fIPKCS7_sign()\fR also applies to \fIPKCS7_verify()\fR.
.SH "SEE ALSO"
ERR_get_error(3), PKCS7_sign(3)
.SH "HISTORY"
\fIPKCS7_verify()\fR was added to OpenSSL 0.9.5

.rn }` ''
.IX Title "PKCS7_verify 3"
.IX Name "PKCS7_verify - verify a PKCS#7 signedData structure"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "VERIFY PROCESS"

.IX Header "NOTES"

.IX Header "RETURN VALUES"

.IX Header "BUGS"

.IX Header "SEE ALSO"

.IX Header "HISTORY"

