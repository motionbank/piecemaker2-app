.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH ecdsa 3 "1.0.1e" "11/Feb/2013" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
ecdsa \- Elliptic Curve Digital Signature Algorithm
.SH "SYNOPSIS"
.PP
.Vb 1
\& #include <openssl/ecdsa.h>
.Ve
.Vb 5
\& ECDSA_SIG*     ECDSA_SIG_new(void);
\& void           ECDSA_SIG_free(ECDSA_SIG *sig);
\& int            i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);
\& ECDSA_SIG*     d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, 
\&                long len);
.Ve
.Vb 20
\& ECDSA_SIG*     ECDSA_do_sign(const unsigned char *dgst, int dgst_len,
\&                        EC_KEY *eckey);
\& ECDSA_SIG*     ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen, 
\&                        const BIGNUM *kinv, const BIGNUM *rp,
\&                        EC_KEY *eckey);
\& int            ECDSA_do_verify(const unsigned char *dgst, int dgst_len,
\&                        const ECDSA_SIG *sig, EC_KEY* eckey);
\& int            ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx,
\&                        BIGNUM **kinv, BIGNUM **rp);
\& int            ECDSA_sign(int type, const unsigned char *dgst,
\&                        int dgstlen, unsigned char *sig,
\&                        unsigned int *siglen, EC_KEY *eckey);
\& int            ECDSA_sign_ex(int type, const unsigned char *dgst,
\&                        int dgstlen, unsigned char *sig,
\&                        unsigned int *siglen, const BIGNUM *kinv, 
\&                        const BIGNUM *rp, EC_KEY *eckey);
\& int            ECDSA_verify(int type, const unsigned char *dgst,
\&                        int dgstlen, const unsigned char *sig,
\&                        int siglen, EC_KEY *eckey);
\& int            ECDSA_size(const EC_KEY *eckey);
.Ve
.Vb 4
\& const ECDSA_METHOD*    ECDSA_OpenSSL(void);
\& void           ECDSA_set_default_method(const ECDSA_METHOD *meth);
\& const ECDSA_METHOD*    ECDSA_get_default_method(void);
\& int            ECDSA_set_method(EC_KEY *eckey,const ECDSA_METHOD *meth);
.Ve
.Vb 6
\& int            ECDSA_get_ex_new_index(long argl, void *argp,
\&                        CRYPTO_EX_new *new_func,
\&                        CRYPTO_EX_dup *dup_func,
\&                        CRYPTO_EX_free *free_func);
\& int            ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);
\& void*          ECDSA_get_ex_data(EC_KEY *d, int idx);
.Ve
.SH "DESCRIPTION"
The \fBECDSA_SIG\fR structure consists of two BIGNUMs for the
r and s value of a ECDSA signature (see X9.62 or FIPS 186-2).
.PP
.Vb 5
\& struct
\&        {
\&        BIGNUM *r;
\&        BIGNUM *s;
\& } ECDSA_SIG;
.Ve
\fIECDSA_SIG_new()\fR allocates a new \fBECDSA_SIG\fR structure (note: this
function also allocates the BIGNUMs) and initialize it.
.PP
\fIECDSA_SIG_free()\fR frees the \fBECDSA_SIG\fR structure \fBsig\fR.
.PP
\fIi2d_ECDSA_SIG()\fR creates the DER encoding of the ECDSA signature
\fBsig\fR and writes the encoded signature to \fB*pp\fR (note: if \fBpp\fR
is NULL \fBi2d_ECDSA_SIG\fR returns the expected length in bytes of 
the DER encoded signature). \fBi2d_ECDSA_SIG\fR returns the length
of the DER encoded signature (or 0 on error).
.PP
\fId2i_ECDSA_SIG()\fR decodes a DER encoded ECDSA signature and returns
the decoded signature in a newly allocated \fBECDSA_SIG\fR structure.
\fB*sig\fR points to the buffer containing the DER encoded signature
of size \fBlen\fR.
.PP
\fIECDSA_size()\fR returns the maximum length of a DER encoded
ECDSA signature created with the private EC key \fBeckey\fR.
.PP
\fIECDSA_sign_setup()\fR may be used to precompute parts of the
signing operation. \fBeckey\fR is the private EC key and \fBctx\fR
is a pointer to \fBBN_CTX\fR structure (or NULL). The precomputed
values or returned in \fBkinv\fR and \fBrp\fR and can be used in a
later call to \fBECDSA_sign_ex\fR or \fBECDSA_do_sign_ex\fR.
.PP
\fIECDSA_sign()\fR is wrapper function for ECDSA_sign_ex with \fBkinv\fR
and \fBrp\fR set to NULL.
.PP
\fIECDSA_sign_ex()\fR computes a digital signature of the \fBdgstlen\fR bytes
hash value \fBdgst\fR using the private EC key \fBeckey\fR and the optional
pre-computed values \fBkinv\fR and \fBrp\fR. The DER encoded signatures is
stored in \fBsig\fR and it's length is returned in \fBsig_len\fR. Note: \fBsig\fR
must point to \fBECDSA_size\fR bytes of memory. The parameter \fBtype\fR
is ignored.
.PP
\fIECDSA_verify()\fR verifies that the signature in \fBsig\fR of size
\fBsiglen\fR is a valid ECDSA signature of the hash value
value \fBdgst\fR of size \fBdgstlen\fR using the public key \fBeckey\fR.
The parameter \fBtype\fR is ignored.
.PP
\fIECDSA_do_sign()\fR is wrapper function for ECDSA_do_sign_ex with \fBkinv\fR
and \fBrp\fR set to NULL.
.PP
\fIECDSA_do_sign_ex()\fR computes a digital signature of the \fBdgst_len\fR
bytes hash value \fBdgst\fR using the private key \fBeckey\fR and the
optional pre-computed values \fBkinv\fR and \fBrp\fR. The signature is
returned in a newly allocated \fBECDSA_SIG\fR structure (or NULL on error).
.PP
\fIECDSA_do_verify()\fR verifies that the signature \fBsig\fR is a valid
ECDSA signature of the hash value \fBdgst\fR of size \fBdgst_len\fR
using the public key \fBeckey\fR.
.SH "RETURN VALUES"
\fIECDSA_size()\fR returns the maximum length signature or 0 on error.
.PP
\fIECDSA_sign_setup()\fR and \fIECDSA_sign()\fR return 1 if successful or 0
on error.
.PP
\fIECDSA_verify()\fR and \fIECDSA_do_verify()\fR return 1 for a valid
signature, 0 for an invalid signature and \-1 on error.
The error codes can be obtained by ERR_get_error(3).
.SH "EXAMPLES"
Creating a ECDSA signature of given SHA\-1 hash value using the
named curve secp192k1.
.PP
First step: create a EC_KEY object (note: this part is \fBnot\fR ECDSA
specific)
.PP
.Vb 16
\& int        ret;
\& ECDSA_SIG *sig;
\& EC_KEY    *eckey = EC_KEY_new();
\& if (eckey == NULL)
\&        {
\&        /* error */
\&        }
\& key->group = EC_GROUP_new_by_nid(NID_secp192k1);
\& if (key->group == NULL)
\&        {
\&        /* error */
\&        }
\& if (!EC_KEY_generate_key(eckey))
\&        {
\&        /* error */
\&        }
.Ve
Second step: compute the ECDSA signature of a SHA\-1 hash value 
using \fBECDSA_do_sign\fR 
.PP
.Vb 5
\& sig = ECDSA_do_sign(digest, 20, eckey);
\& if (sig == NULL)
\&        {
\&        /* error */
\&        }
.Ve
or using \fBECDSA_sign\fR
.PP
.Vb 9
\& unsigned char *buffer, *pp;
\& int            buf_len;
\& buf_len = ECDSA_size(eckey);
\& buffer  = OPENSSL_malloc(buf_len);
\& pp = buffer;
\& if (!ECDSA_sign(0, dgst, dgstlen, pp, &buf_len, eckey);
\&        {
\&        /* error */
\&        }
.Ve
Third step: verify the created ECDSA signature using \fBECDSA_do_verify\fR
.PP
.Vb 1
\& ret = ECDSA_do_verify(digest, 20, sig, eckey);
.Ve
or using \fBECDSA_verify\fR
.PP
.Vb 1
\& ret = ECDSA_verify(0, digest, 20, buffer, buf_len, eckey);
.Ve
and finally evaluate the return value:
.PP
.Vb 12
\& if (ret == -1)
\&        {
\&        /* error */
\&        }
\& else if (ret == 0)
\&        {
\&        /* incorrect signature */
\&        }
\& else   /* ret == 1 */
\&        {
\&        /* signature ok */
\&        }
.Ve
.SH "CONFORMING TO"
ANSI X9.62, US Federal Information Processing Standard FIPS 186-2
(Digital Signature Standard, DSS)
.SH "SEE ALSO"
dsa(3), rsa(3)
.SH "HISTORY"
The ecdsa implementation was first introduced in OpenSSL 0.9.8
.SH "AUTHOR"
Nils Larsch for the OpenSSL project (http://www.openssl.org).

.rn }` ''
.IX Title "ecdsa 3"
.IX Name "ecdsa - Elliptic Curve Digital Signature Algorithm"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "RETURN VALUES"

.IX Header "EXAMPLES"

.IX Header "CONFORMING TO"

.IX Header "SEE ALSO"

.IX Header "HISTORY"

.IX Header "AUTHOR"

